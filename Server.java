/**
 * Autor Xianfu Sun File Server
 * The server assign each proxies an unique service code
 * and make a directory for each proxies based on the service code
 * And whenever a proxy ask for transfering or pushing a file
 * it needs to include that service code in RPC in order for the
 * server to know which directory it needs to get to
 * The server expects the proxy to call disconnect when the proxy quits
 * And it cleans up all the files generated by that proxy.
 */

import java.io.*;
import java.nio.ByteBuffer;
import java.nio.file.Files;
import java.rmi.Remote;
import java.rmi.server.UnicastRemoteObject;
import java.rmi.RemoteException;
import java.rmi.registry.*;
import java.rmi.Naming;
import java.net.MalformedURLException;
import java.util.concurrent.ConcurrentHashMap;
import java.nio.file.StandardCopyOption;

/**
 * Server class
 */
class Server extends UnicastRemoteObject implements FileTransmit {
    private static String PORT; //port num for the server
    private static String ROOT; //root directory for the server
    private static Long client_id; //history of clients
    //version map of a directory of one file to its version
    private static ConcurrentHashMap<String, Integer> versionMap;
    /**
     * Constructor for the server
     */
    public Server(String port, String root_dir) throws RemoteException {
        super(0);
        PORT = port;
        ROOT = root_dir;
        client_id = 0l;
        versionMap = new ConcurrentHashMap<String, Integer>();
    }

    /**
     * delete a file denoted by the path name.
     * @param path simplified path name denoted by the proxy
     * @return true on success, else false
     * @throws RemoteException
     * @throws IOException
     */
    public Boolean delete(String path) throws RemoteException, IOException{
        //create file from the root dir
        File f = new File(ROOT + "/" + path);
        if (!f.exists()) {
            System.out.println("delete file does not exists!");
            return false;
        }
        try {
            f.delete();
            versionMap.remove(path); //remove from the versionMap
        } catch (Exception e) {
            System.out.println(e);
        }
        return true;
    }

    /**
     * check if the file existing on the server
     * @param path simplified pathname
     * @return true if exist else false
     * @throws RemoteException
     */
    public Boolean exists(String path) throws RemoteException {
        File f = new File(ROOT + "/" + path);
        return f.exists();
    }

    /**
     * get the file info from the server(version and filesize)
     * @param filename simplified pathname
     * @return the array of the information [version, filesize]
     * @throws RemoteException
     */
    public int[] getFileInfo(String filename) throws RemoteException {
        int[] rv = new int[2];
        int file_size = 0;
        int version = 0;
        //convert to root directory
        File f = new File(ROOT + "/" + filename);
        if (f.exists()) {
            file_size = (int)f.length();
            if (versionMap.containsKey(filename)) {
                version = versionMap.get(filename);
            } else {
                version = 0; //contain this file but does not have entry
                versionMap.put(filename, 0); //update.
            }
        } else { //file does not exists at all
            version = -1;
        }
        rv[0] = version;
        rv[1] = file_size;
        return rv;
    }

    /**
     * create a working directory to a specific client.
     * and return that service id to the client.
     * the client need to call this in order to get a service id first.
     */
    public long connect() throws RemoteException {
        long serveid;
        synchronized(client_id) {
            serveid = client_id++;
        }
        try {
            System.out.println(String.format("Client %d connect to the server", serveid));
            File f = new File("client" + String.valueOf(serveid));
            f.mkdir();
        } catch (Exception e) {
            System.out.println(e);
        }
        return serveid;
    }

    /**
     * the proxy should do this when exit.
     * So the server can do the cleaning jobs.
     */
    public void disconnect(long serveid) throws RemoteException{
        File dir = new File("client" + String.valueOf(serveid));
        File[] files = dir.listFiles();
        for (int i = 0; i < files.length; i++) {
            files[i].delete();
        }
        dir.delete();
    }

    /**
     * Creating a tempfile for transfering file to proxy from server
     * It used a duplicated file in a client-specific directory
     * which is personalized by its service id.
     * @param path simplfied pathname
     * @param start start position to copy the file
     * @param size maximum size to read file
     * @param service_id service id given by the clients
     * @return null IF ANY exception happens, empty buf if reaches EOF
     * otherwise the content of read file
     * @throws RemoteException
     */
    public byte[] transfer(String path, int start, int size, long service_id) throws RemoteException {
        //we should check the validity of this path first
        File f = new File(ROOT +"/"+path); //convert to search from the root directory

        if (!f.exists()) {//file does not exist in the servers' working directory
            System.out.println(String.format("Server: File %s does not exist in server dir", f.getPath()));
            return null;
        }
        String client_dir = "client" + String.valueOf(service_id);
        File tempFile = new File(client_dir + "/"+ f.getName());
        try {
            if (!tempFile.exists()) { //create a new version of tempfile
                // this methods is blocked
                Files.copy(f.toPath(), tempFile.toPath(), StandardCopyOption.REPLACE_EXISTING);
            }

            if (!versionMap.containsKey(path)) {//creat a entry in the version map
                versionMap.put(path, 0);
            }
            RandomAccessFile raf = new RandomAccessFile(tempFile, "r");
            //allocate four more bytes to store the size of trasmission information
            ByteBuffer bf = ByteBuffer.allocate(4);
            raf.seek(start); //get to the start point
            byte[] buffer = new byte[size + 4];
            int read_bytes = raf.read(buffer, 4, size);//copy contents
            bf.putInt(0, read_bytes); //put integer to the buffer
            bf.position(0); //reset position
            bf.get(buffer, 0, 4); //copy from byte buffer to the return buffer
            raf.close();
            if (read_bytes + start == tempFile.length() || read_bytes == -1) {
                //eof of the file, clean up the temp file
                tempFile.delete();
            }
            return buffer;
        } catch (IOException e) {
            System.out.println("Serverside exception");
            System.out.println(e);
            return null;
        }
    }

    /**
     * Push the file back to the server
     * It is only write to a temp file created in the client's directory
     * And only replace the oringal file when the proxy explicitly stated eof.
     * @param path Simplified pathname
     * @param content content to overwrite to the file
     * @param size size to write
     * @param start start position
     * @param service_id service id given by the clients
     * @return 0 on success else a negative number
     * @throws RemoteException
     */
    public int push(String path, byte[]content, int size, long start, long service_id) throws RemoteException {
        String client_dir = "client" + String.valueOf(service_id);
        //go to the client dir
        File o_file = new File(ROOT + "/" + path);
        //create a temp file
        File temp_file = new File(client_dir + "/" + o_file.getName());
        try {
            if (size == -1) {//signal a eof from client
                //copy the the file to substitute the original file
                Files.copy(temp_file.toPath(), o_file.toPath(), StandardCopyOption.REPLACE_EXISTING);
                //update the version id
                if (versionMap.containsKey(path)) {
                    int old_vid = versionMap.get(path);
                    versionMap.replace(path, old_vid + 1);
                } else {
                    versionMap.put(path, 0);
                }
                temp_file.delete();
                return 0;
            }
            RandomAccessFile raf = new RandomAccessFile(temp_file, "rw");
            raf.seek(start); //get to the start point
            raf.write(content, 0, size);
            raf.close();
        } catch (IOException e) {
            System.out.println(e);
            return -1;
        }
        return 0;
    }

    //main
    public static void main(String[] args) {
        //read the arguments
        String port = args[0];
        String root = args[1];
        //register
        try {
            LocateRegistry.createRegistry(Integer.parseInt(port));
            Server server = new Server(port, root);
            Naming.rebind("//127.0.0.1:"+port+"/Server", server);
        }catch (RemoteException e) {
            System.out.println(e);
            return;
        } catch (MalformedURLException e) {
            System.out.println(e);
            return;
        }
    }
}